---
title: "Exploring Labour data"
format: 
  html:
    toc: true
jupyter: python3
editor: 
  render-on-save: true
---

# Setup

## Parameters

```{python}
from pyprojroot import here
```
```{python}
# | tags: [parameters]
LABOUR_DATA_FILE = here() / "data" / "14100355.csv"
```

## Libraries

```{python}
import polars as pl
import polars.selectors as cs
from mizani.bounds import squish
from pyprojroot import here
from great_tables import GT, md, html
from plotnine import *
from labourcan.data_processing import read_labourcan
```

## Read data

[read_labourcan](../py/labourcan/data_processing.py) returns a polars dataframe with columns:

- Unnecessary metadata columns removed
- Filtered to seasonally adjusted estimates only
- Additional `YEAR`, `MONTH`, and `DATE_YMD` columns extracted from `REF_DATE`
- Sorted chronologically by year and month


```{python}
labour = read_labourcan(LABOUR_DATA_FILE)
#   .with_columns(pl.col("VALUE").replace("", "0.0").cast(pl.Float64))
#        pl.col("GEO") == "Canada",
#      ~pl.col('North American Industry Classification System (NAICS)').is_in([
# 'Total employed, all industries',
# 'Goods-producing sector',
# 'Services-producing sector'
# ]),
labour.glimpse()
```


# Process data

For our graphic, we need to make this variable: **signed rank in change in # of jobs**

*Signed* rank means that the rank is effectively computed over negative and positive %change separately, and in opposite directions (descending for negative, and ascending for positive).

Meaning the highest negative value (closest to 0) is rank=-1, and lowest positive value (closets to 0) is rank=1

e.g.

```
[-0.01, -0.02, 0.01, 0.02] = 
[-1, -2, 1, 2]
```

## % Change per month

First, compute % change from previous month

Do this for each industry * labour force characteristic

```{python}
labour_processed = (
    # if we sort acesnding by time, then lag value is the month before
    labour.sort(["Industry", "YEAR", "MONTH"])
    .with_columns(
        LAGGED_VALUE=pl.col("VALUE")
        .shift(1)
        .over(["Industry"])
    )
    # compute percent difference
    .with_columns((pl.col("VALUE") - pl.col("LAGGED_VALUE")).alias("DIFF"))
    .with_columns((pl.col("DIFF") / pl.col("LAGGED_VALUE")).alias("PDIFF"))
    .select(
        pl.col("Industry"),
        cs.matches("Labour force characteristics"),
        pl.col("DATE_YMD"),
        pl.col("YEAR"),
        pl.col("MONTH"),
        cs.matches("VALUE"),
        cs.matches("DIFF"),
    )
    .sort(["Industry", "YEAR", "MONTH", "PDIFF"])
)
labour_processed
```

## Centered rank

Now we can compute **Signed Ascending Rank of industry by % change**

Define centered_rank_expr function which takes a polars series and returns an expression, meaning it can be used in a polars `with_columns` call, which is nice because it can take advantage of polars lazy-evaluation optimization.

- Leverages Polars' optimized expressions
- Works well with lazy evaluation
- Scales better with large datasets
- Integrates seamlessly with other Polars operations

```{python}
def centered_rank_expr(col):
    """
    - Largest negative value gets rank -1
    - Smallest positive value gets rank +1
    - Zero gets rank 0
    """
    return (
        pl.when(col < 0)
        .then(
            # minus the total # of -ve values
            (col.rank(method="ordinal", descending=True) * -1) + (col > 0).sum()
        )
        .when(col == 0)
        .then(pl.lit(0))
        .when(col > 0)
        .then(col.rank(method="ordinal") - (col < 0).sum())
        .otherwise(pl.lit(None))
    )


test_series = (
    # .filter(pl.col("Labour force characteristics") == "Employment")
    labour_processed
    .with_columns(pl.col("PDIFF").round(decimals=4))
    .filter(pl.col("YEAR") == 2025, pl.col("MONTH") == 1)
    .select(pl.col("PDIFF"))
    .sample(n=3, seed=1)
    .select("PDIFF")
)

test_series.with_columns(centered_rank_expr(pl.col("PDIFF")).alias("rank")).sort(
    "PDIFF"
)
```


Apply to data

```{python}
labour_processed = labour_processed.with_columns(
    centered_rank_across_industry=centered_rank_expr(pl.col("PDIFF")).over(
        ["YEAR", "MONTH"]
    )
)
labour_processed
```


```{python}
# check 1 year 1 month
(
    labour_processed
    .with_columns(pl.col("PDIFF").round(decimals=4))
    .filter(pl.col("YEAR") == 2025)
    .sort(["YEAR", "MONTH", "PDIFF"])
    .select(["YEAR", "MONTH", "PDIFF", cs.matches("rank")])
)
```

```{python}
(
    ggplot(
        (
            labour_processed.filter(
                pl.col("YEAR") >= 2000,
                pl.col("YEAR") <= 2025
            )
        ), aes(x="DATE_YMD", y="centered_rank_across_industry", color="PDIFF"))
    + geom_point(shape="s")
    + theme_tufte()
    + theme(figure_size=(10, 4), axis_text_x=element_text(angle=90))

    + scale_color_gradient2(
        limits=(-0.01, 0.01), low="#ff0000ff", high="#0000dbff", midpoint=0, oob=squish)
)
```

TRy with ordinal
```{python}
plot_data = labour_processed.filter(
    pl.col("YEAR") >= 2008,
    pl.col("YEAR") <= 2025
).drop_nulls(
    ['centered_rank_across_industry']
)
order = (
    plot_data.select('centered_rank_across_industry').unique().sort(
        'centered_rank_across_industry')
    .to_series()
    .cast(pl.Utf8)
    .to_list()
)

plot_data = (
    plot_data.with_columns(
        pl.col('centered_rank_across_industry').cast(
            pl.Utf8).cast(pl.Enum(categories=order))
    )
)

(
    ggplot(plot_data, aes(x="DATE_YMD",
           y="centered_rank_across_industry", fill="PDIFF"))
    + geom_tile()
    + theme_tufte()
    + theme(
      figure_size=(10, 10), 
      aspect_ratio=0.25,
      axis_text_x=element_text(angle=90)
      )
      +coord_equal() 
    + scale_fill_gradient2(
        limits=(-0.01, 0.01), low="#ff0000ff", high="#0000dbff", midpoint=0, oob=squish)

)
```

# Exploratory

```{python}
# | eval: false
(
    ggplot(
        (
            labour_processed.filter(
                pl.col("YEAR") >= 2008,
                pl.col("YEAR") <= 2025,
                pl.col('Industry') == 'Total employed, all industries'
            )
        ),
        aes(x="DATE_YMD", y="VALUE", color="Industry"),
    )
    # + geom_point()
    + geom_line()
    + theme_tufte()
    + theme(figure_size=(6, 4), legend_position='top')
)
```